{"version":3,"file":"tsparticles.js","names":["container","position","particlesOptions","container"],"sources":["../../tsparticles-plugin-absorbers/esm/Options/Classes/AbsorberSizeLimit.js","../../tsparticles-plugin-absorbers/esm/Options/Classes/AbsorberSize.js","../../tsparticles-plugin-absorbers/esm/Options/Classes/Absorber.js","../../tsparticles-plugin-absorbers/esm/AbsorberInstance.js","../../tsparticles-plugin-absorbers/esm/Absorbers.js","../../tsparticles-plugin-absorbers/esm/index.js","../../tsparticles-updater-destroy/esm/Options/Classes/DestroyBounds.js","../../tsparticles-updater-destroy/esm/Options/Classes/SplitFactor.js","../../tsparticles-updater-destroy/esm/Options/Classes/SplitRate.js","../../tsparticles-updater-destroy/esm/Options/Classes/Split.js","../../tsparticles-updater-destroy/esm/Options/Classes/Destroy.js","../../tsparticles-updater-destroy/esm/Utils.js","../../tsparticles-updater-destroy/esm/DestroyUpdater.js","../../tsparticles-updater-destroy/esm/index.js","../../tsparticles-plugin-emitters/esm/Shapes/Circle/CircleShape.js","../../tsparticles-plugin-emitters/esm/Options/Classes/EmitterLife.js","../../tsparticles-plugin-emitters/esm/Options/Classes/EmitterRate.js","../../tsparticles-plugin-emitters/esm/Options/Classes/EmitterSize.js","../../tsparticles-plugin-emitters/esm/Options/Classes/Emitter.js","../../tsparticles-plugin-emitters/esm/EmitterInstance.js","../../tsparticles-plugin-emitters/esm/Emitters.js","../../tsparticles-plugin-emitters/esm/ShapeManager.js","../../tsparticles-plugin-emitters/esm/Shapes/Square/SquareShape.js","../../tsparticles-plugin-emitters/esm/index.js","../../tsparticles-interaction-external-trail/esm/Options/Classes/Trail.js","../../tsparticles-interaction-external-trail/esm/TrailMaker.js","../../tsparticles-interaction-external-trail/esm/index.js","../../tsparticles-updater-roll/esm/Utils.js","../../tsparticles-updater-roll/esm/Options/Classes/RollLight.js","../../tsparticles-updater-roll/esm/Options/Classes/Roll.js","../../tsparticles-updater-roll/esm/RollUpdater.js","../../tsparticles-updater-roll/esm/index.js","../../tsparticles-updater-tilt/esm/Options/Classes/TiltAnimation.js","../../tsparticles-updater-tilt/esm/Options/Classes/Tilt.js","../../tsparticles-updater-tilt/esm/Utils.js","../../tsparticles-updater-tilt/esm/TiltUpdater.js","../../tsparticles-updater-tilt/esm/index.js","../../tsparticles-updater-twinkle/esm/Options/Classes/TwinkleValues.js","../../tsparticles-updater-twinkle/esm/Options/Classes/Twinkle.js","../../tsparticles-updater-twinkle/esm/TwinkleUpdater.js","../../tsparticles-updater-twinkle/esm/index.js","../../tsparticles-updater-wobble/esm/Options/Classes/WobbleSpeed.js","../../tsparticles-updater-wobble/esm/Options/Classes/Wobble.js","../../tsparticles-updater-wobble/esm/Utils.js","../../tsparticles-updater-wobble/esm/WobbleUpdater.js","../../tsparticles-updater-wobble/esm/index.js","../../tsparticles/esm/index.js"],"sourcesContent":["export class AbsorberSizeLimit {\n    constructor() {\n        this.radius = 0;\n        this.mass = 0;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.mass !== undefined) {\n            this.mass = data.mass;\n        }\n        if (data.radius !== undefined) {\n            this.radius = data.radius;\n        }\n    }\n}\n","import { ValueWithRandom, isNumber } from \"tsparticles-engine\";\nimport { AbsorberSizeLimit } from \"./AbsorberSizeLimit\";\nexport class AbsorberSize extends ValueWithRandom {\n    constructor() {\n        super();\n        this.density = 5;\n        this.value = 50;\n        this.limit = new AbsorberSizeLimit();\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        super.load(data);\n        if (data.density !== undefined) {\n            this.density = data.density;\n        }\n        if (isNumber(data.limit)) {\n            this.limit.radius = data.limit;\n        }\n        else {\n            this.limit.load(data.limit);\n        }\n    }\n}\n","import { OptionsColor, setRangeValue, } from \"tsparticles-engine\";\nimport { AbsorberSize } from \"./AbsorberSize\";\nexport class Absorber {\n    constructor() {\n        this.color = new OptionsColor();\n        this.color.value = \"#000000\";\n        this.draggable = false;\n        this.opacity = 1;\n        this.destroy = true;\n        this.orbits = false;\n        this.size = new AbsorberSize();\n    }\n    load(data) {\n        if (data === undefined) {\n            return;\n        }\n        if (data.color !== undefined) {\n            this.color = OptionsColor.create(this.color, data.color);\n        }\n        if (data.draggable !== undefined) {\n            this.draggable = data.draggable;\n        }\n        this.name = data.name;\n        if (data.opacity !== undefined) {\n            this.opacity = data.opacity;\n        }\n        if (data.position !== undefined) {\n            this.position = {};\n            if (data.position.x !== undefined) {\n                this.position.x = setRangeValue(data.position.x);\n            }\n            if (data.position.y !== undefined) {\n                this.position.y = setRangeValue(data.position.y);\n            }\n        }\n        if (data.size !== undefined) {\n            this.size.load(data.size);\n        }\n        if (data.destroy !== undefined) {\n            this.destroy = data.destroy;\n        }\n        if (data.orbits !== undefined) {\n            this.orbits = data.orbits;\n        }\n    }\n}\n","import { Vector, calcPositionOrRandomFromSize, calcPositionOrRandomFromSizeRanged, getDistance, getDistances, getRandom, getRangeValue, getStyleFromRgb, isPointInside, rangeColorToRgb, } from \"tsparticles-engine\";\nimport { Absorber } from \"./Options/Classes/Absorber\";\nexport class AbsorberInstance {\n    constructor(absorbers, container, options, position) {\n        this.absorbers = absorbers;\n        this.container = container;\n        this._calcPosition = () => {\n            const exactPosition = calcPositionOrRandomFromSizeRanged({\n                size: this.container.canvas.size,\n                position: this.options.position,\n            });\n            return Vector.create(exactPosition.x, exactPosition.y);\n        };\n        this._updateParticlePosition = (particle, v) => {\n            if (particle.destroyed) {\n                return;\n            }\n            const container = this.container, canvasSize = container.canvas.size;\n            if (particle.needsNewPosition) {\n                const newPosition = calcPositionOrRandomFromSize({ size: canvasSize });\n                particle.position.setTo(newPosition);\n                particle.velocity.setTo(particle.initialVelocity);\n                particle.absorberOrbit = undefined;\n                particle.needsNewPosition = false;\n            }\n            if (this.options.orbits) {\n                if (particle.absorberOrbit === undefined) {\n                    particle.absorberOrbit = Vector.create(0, 0);\n                    particle.absorberOrbit.length = getDistance(particle.getPosition(), this.position);\n                    particle.absorberOrbit.angle = getRandom() * Math.PI * 2;\n                }\n                if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {\n                    const minSize = Math.min(canvasSize.width, canvasSize.height);\n                    particle.absorberOrbit.length = minSize * (1 + (getRandom() * 0.2 - 0.1));\n                }\n                if (particle.absorberOrbitDirection === undefined) {\n                    particle.absorberOrbitDirection =\n                        particle.velocity.x >= 0 ? \"clockwise\" : \"counter-clockwise\";\n                }\n                const orbitRadius = particle.absorberOrbit.length, orbitAngle = particle.absorberOrbit.angle, orbitDirection = particle.absorberOrbitDirection;\n                particle.velocity.setTo(Vector.origin);\n                const updateFunc = {\n                    x: orbitDirection === \"clockwise\" ? Math.cos : Math.sin,\n                    y: orbitDirection === \"clockwise\" ? Math.sin : Math.cos,\n                };\n                particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);\n                particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);\n                particle.absorberOrbit.length -= v.length;\n                particle.absorberOrbit.angle +=\n                    (((particle.retina.moveSpeed ?? 0) * container.retina.pixelRatio) / 100) *\n                        container.retina.reduceFactor;\n            }\n            else {\n                const addV = Vector.origin;\n                addV.length = v.length;\n                addV.angle = v.angle;\n                particle.velocity.addTo(addV);\n            }\n        };\n        this.initialPosition = position ? Vector.create(position.x, position.y) : undefined;\n        if (options instanceof Absorber) {\n            this.options = options;\n        }\n        else {\n            this.options = new Absorber();\n            this.options.load(options);\n        }\n        this.dragging = false;\n        this.name = this.options.name;\n        this.opacity = this.options.opacity;\n        this.size = getRangeValue(this.options.size.value) * container.retina.pixelRatio;\n        this.mass = this.size * this.options.size.density * container.retina.reduceFactor;\n        const limit = this.options.size.limit;\n        this.limit = {\n            radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,\n            mass: limit.mass,\n        };\n        this.color = rangeColorToRgb(this.options.color) ?? {\n            b: 0,\n            g: 0,\n            r: 0,\n        };\n        this.position = this.initialPosition?.copy() ?? this._calcPosition();\n    }\n    attract(particle) {\n        const container = this.container, options = this.options;\n        if (options.draggable) {\n            const mouse = container.interactivity.mouse;\n            if (mouse.clicking && mouse.downPosition) {\n                const mouseDist = getDistance(this.position, mouse.downPosition);\n                if (mouseDist <= this.size) {\n                    this.dragging = true;\n                }\n            }\n            else {\n                this.dragging = false;\n            }\n            if (this.dragging && mouse.position) {\n                this.position.x = mouse.position.x;\n                this.position.y = mouse.position.y;\n            }\n        }\n        const pos = particle.getPosition(), { dx, dy, distance } = getDistances(this.position, pos), v = Vector.create(dx, dy);\n        v.length = (this.mass / Math.pow(distance, 2)) * container.retina.reduceFactor;\n        if (distance < this.size + particle.getRadius()) {\n            const sizeFactor = particle.getRadius() * 0.033 * container.retina.pixelRatio;\n            if ((this.size > particle.getRadius() && distance < this.size - particle.getRadius()) ||\n                (particle.absorberOrbit !== undefined && particle.absorberOrbit.length < 0)) {\n                if (options.destroy) {\n                    particle.destroy();\n                }\n                else {\n                    particle.needsNewPosition = true;\n                    this._updateParticlePosition(particle, v);\n                }\n            }\n            else {\n                if (options.destroy) {\n                    particle.size.value -= sizeFactor;\n                }\n                this._updateParticlePosition(particle, v);\n            }\n            if (this.limit.radius <= 0 || this.size < this.limit.radius) {\n                this.size += sizeFactor;\n            }\n            if (this.limit.mass <= 0 || this.mass < this.limit.mass) {\n                this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;\n            }\n        }\n        else {\n            this._updateParticlePosition(particle, v);\n        }\n    }\n    draw(context) {\n        context.translate(this.position.x, this.position.y);\n        context.beginPath();\n        context.arc(0, 0, this.size, 0, Math.PI * 2, false);\n        context.closePath();\n        context.fillStyle = getStyleFromRgb(this.color, this.opacity);\n        context.fill();\n    }\n    resize() {\n        const initialPosition = this.initialPosition;\n        this.position =\n            initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin)\n                ? initialPosition\n                : this._calcPosition();\n    }\n}\n","import { executeOnSingleOrMultiple, isNumber, itemFromSingleOrMultiple, } from \"tsparticles-engine\";\nimport { AbsorberInstance } from \"./AbsorberInstance\";\nexport class Absorbers {\n    constructor(container) {\n        this.container = container;\n        this.array = [];\n        this.absorbers = [];\n        this.interactivityAbsorbers = [];\n        container.getAbsorber = (idxOrName) => idxOrName === undefined || isNumber(idxOrName)\n            ? this.array[idxOrName || 0]\n            : this.array.find((t) => t.name === idxOrName);\n        container.addAbsorber = (options, position) => this.addAbsorber(options, position);\n    }\n    addAbsorber(options, position) {\n        const absorber = new AbsorberInstance(this, this.container, options, position);\n        this.array.push(absorber);\n        return absorber;\n    }\n    draw(context) {\n        for (const absorber of this.array) {\n            absorber.draw(context);\n        }\n    }\n    handleClickMode(mode) {\n        const absorberOptions = this.absorbers, modeAbsorbers = this.interactivityAbsorbers;\n        if (mode === \"absorber\") {\n            const absorbersModeOptions = itemFromSingleOrMultiple(modeAbsorbers), absorbersOptions = absorbersModeOptions ?? itemFromSingleOrMultiple(absorberOptions), aPosition = this.container.interactivity.mouse.clickPosition;\n            this.addAbsorber(absorbersOptions, aPosition);\n        }\n    }\n    async init() {\n        this.absorbers = this.container.actualOptions.absorbers;\n        this.interactivityAbsorbers = this.container.actualOptions.interactivity.modes.absorbers;\n        executeOnSingleOrMultiple(this.absorbers, (absorber) => {\n            this.addAbsorber(absorber);\n        });\n    }\n    particleUpdate(particle) {\n        for (const absorber of this.array) {\n            absorber.attract(particle);\n            if (particle.destroyed) {\n                break;\n            }\n        }\n    }\n    removeAbsorber(absorber) {\n        const index = this.array.indexOf(absorber);\n        if (index >= 0) {\n            this.array.splice(index, 1);\n        }\n    }\n    resize() {\n        for (const absorber of this.array) {\n            absorber.resize();\n        }\n    }\n    stop() {\n        this.array = [];\n    }\n}\n","import { executeOnSingleOrMultiple, isArray, isInArray, } from \"tsparticles-engine\";\nimport { Absorber } from \"./Options/Classes/Absorber\";\nimport { Absorbers } from \"./Absorbers\";\nclass AbsorbersPlugin {\n    constructor() {\n        this.id = \"absorbers\";\n    }\n    getPlugin(container) {\n        return new Absorbers(container);\n    }\n    loadOptions(options, source) {\n        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {\n            return;\n        }\n        if (source?.absorbers) {\n            options.absorbers = executeOnSingleOrMultiple(source.absorbers, (absorber) => {\n                const tmp = new Absorber();\n                tmp.load(absorber);\n                return tmp;\n            });\n        }\n        options.interactivity.modes.absorbers = executeOnSingleOrMultiple(source?.interactivity?.modes?.absorbers, (absorber) => {\n            const tmp = new Absorber();\n            tmp.load(absorber);\n            return tmp;\n        });\n    }\n    needsPlugin(options) {\n        if (!options) {\n            return false;\n        }\n        const absorbers = options.absorbers;\n        if (isArray(absorbers)) {\n            return !!absorbers.length;\n        }\n        else if (absorbers) {\n            return true;\n        }\n        else if (options.interactivity?.events?.onClick?.mode &&\n            isInArray(\"absorber\", options.interactivity.events.onClick.mode)) {\n            return true;\n        }\n        return false;\n    }\n}\nexport async function loadAbsorbersPlugin(engine, refresh = true) {\n    await engine.addPlugin(new AbsorbersPlugin(), refresh);\n}\nexport * from \"./AbsorberContainer\";\nexport * from \"./Enums/AbsorberClickMode\";\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class DestroyBounds {\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.bottom !== undefined) {\n            this.bottom = setRangeValue(data.bottom);\n        }\n        if (data.left !== undefined) {\n            this.left = setRangeValue(data.left);\n        }\n        if (data.right !== undefined) {\n            this.right = setRangeValue(data.right);\n        }\n        if (data.top !== undefined) {\n            this.top = setRangeValue(data.top);\n        }\n    }\n}\n","import { ValueWithRandom } from \"tsparticles-engine\";\nexport class SplitFactor extends ValueWithRandom {\n    constructor() {\n        super();\n        this.value = 3;\n    }\n}\n","import { ValueWithRandom } from \"tsparticles-engine\";\nexport class SplitRate extends ValueWithRandom {\n    constructor() {\n        super();\n        this.value = { min: 4, max: 9 };\n    }\n}\n","import { OptionsColor, deepExtend, executeOnSingleOrMultiple, } from \"tsparticles-engine\";\nimport { SplitFactor } from \"./SplitFactor\";\nimport { SplitRate } from \"./SplitRate\";\nexport class Split {\n    constructor() {\n        this.count = 1;\n        this.factor = new SplitFactor();\n        this.rate = new SplitRate();\n        this.sizeOffset = true;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.color !== undefined) {\n            this.color = OptionsColor.create(this.color, data.color);\n        }\n        if (data.count !== undefined) {\n            this.count = data.count;\n        }\n        this.factor.load(data.factor);\n        this.rate.load(data.rate);\n        this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {\n            return deepExtend({}, particles);\n        });\n        if (data.sizeOffset !== undefined) {\n            this.sizeOffset = data.sizeOffset;\n        }\n        if (data.colorOffset) {\n            this.colorOffset = this.colorOffset ?? {};\n            if (data.colorOffset.h !== undefined) {\n                this.colorOffset.h = data.colorOffset.h;\n            }\n            if (data.colorOffset.s !== undefined) {\n                this.colorOffset.s = data.colorOffset.s;\n            }\n            if (data.colorOffset.l !== undefined) {\n                this.colorOffset.l = data.colorOffset.l;\n            }\n        }\n    }\n}\n","import { DestroyBounds } from \"./DestroyBounds\";\nimport { Split } from \"./Split\";\nexport class Destroy {\n    constructor() {\n        this.bounds = new DestroyBounds();\n        this.mode = \"none\";\n        this.split = new Split();\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.mode) {\n            this.mode = data.mode;\n        }\n        if (data.bounds) {\n            this.bounds.load(data.bounds);\n        }\n        this.split.load(data.split);\n    }\n}\n","import { getRangeValue, getValue, isNumber, itemFromSingleOrMultiple, loadParticlesOptions, randomInRange, setRangeValue, } from \"tsparticles-engine\";\nfunction addSplitParticle(engine, container, parent, splitParticlesOptions) {\n    const destroyOptions = parent.options.destroy;\n    if (!destroyOptions) {\n        return;\n    }\n    const splitOptions = destroyOptions.split, options = loadParticlesOptions(engine, container, parent.options), factor = getValue(splitOptions.factor), parentColor = parent.getFillColor();\n    if (splitOptions.color) {\n        options.color.load(splitOptions.color);\n    }\n    else if (splitOptions.colorOffset && parentColor) {\n        options.color.load({\n            value: {\n                hsl: {\n                    h: parentColor.h + getRangeValue(splitOptions.colorOffset.h ?? 0),\n                    s: parentColor.s + getRangeValue(splitOptions.colorOffset.s ?? 0),\n                    l: parentColor.l + getRangeValue(splitOptions.colorOffset.l ?? 0),\n                },\n            },\n        });\n    }\n    else {\n        options.color.load({\n            value: {\n                hsl: parent.getFillColor(),\n            },\n        });\n    }\n    options.move.load({\n        center: {\n            x: parent.position.x,\n            y: parent.position.y,\n            mode: \"precise\",\n        },\n    });\n    if (isNumber(options.size.value)) {\n        options.size.value /= factor;\n    }\n    else {\n        options.size.value.min /= factor;\n        options.size.value.max /= factor;\n    }\n    options.load(splitParticlesOptions);\n    const offset = splitOptions.sizeOffset ? setRangeValue(-parent.size.value, parent.size.value) : 0, position = {\n        x: parent.position.x + randomInRange(offset),\n        y: parent.position.y + randomInRange(offset),\n    };\n    return container.particles.addParticle(position, options, parent.group, (particle) => {\n        if (particle.size.value < 0.5) {\n            return false;\n        }\n        particle.velocity.length = randomInRange(setRangeValue(parent.velocity.length, particle.velocity.length));\n        particle.splitCount = (parent.splitCount ?? 0) + 1;\n        particle.unbreakable = true;\n        setTimeout(() => {\n            particle.unbreakable = false;\n        }, 500);\n        return true;\n    });\n}\nexport function split(engine, container, particle) {\n    const destroyOptions = particle.options.destroy;\n    if (!destroyOptions) {\n        return;\n    }\n    const splitOptions = destroyOptions.split;\n    if (splitOptions.count >= 0 && (particle.splitCount === undefined || particle.splitCount++ > splitOptions.count)) {\n        return;\n    }\n    const rate = getValue(splitOptions.rate), particlesSplitOptions = itemFromSingleOrMultiple(splitOptions.particles);\n    for (let i = 0; i < rate; i++) {\n        addSplitParticle(engine, container, particle, particlesSplitOptions);\n    }\n}\n","import { getRangeValue, } from \"tsparticles-engine\";\nimport { Destroy } from \"./Options/Classes/Destroy\";\nimport { split } from \"./Utils\";\nexport class DestroyUpdater {\n    constructor(engine, container) {\n        this.engine = engine;\n        this.container = container;\n    }\n    init(particle) {\n        const container = this.container, particlesOptions = particle.options, destroyOptions = particlesOptions.destroy;\n        if (!destroyOptions) {\n            return;\n        }\n        particle.splitCount = 0;\n        const destroyBoundsOptions = destroyOptions.bounds;\n        if (!particle.destroyBounds) {\n            particle.destroyBounds = {};\n        }\n        const { bottom, left, right, top } = destroyBoundsOptions, { destroyBounds } = particle, canvasSize = container.canvas.size;\n        if (bottom) {\n            destroyBounds.bottom = (getRangeValue(bottom) * canvasSize.height) / 100;\n        }\n        if (left) {\n            destroyBounds.left = (getRangeValue(left) * canvasSize.width) / 100;\n        }\n        if (right) {\n            destroyBounds.right = (getRangeValue(right) * canvasSize.width) / 100;\n        }\n        if (top) {\n            destroyBounds.top = (getRangeValue(top) * canvasSize.height) / 100;\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.destroy) {\n            options.destroy = new Destroy();\n        }\n        for (const source of sources) {\n            options.destroy.load(source?.destroy);\n        }\n    }\n    particleDestroyed(particle, override) {\n        if (override) {\n            return;\n        }\n        const destroyOptions = particle.options.destroy;\n        if (destroyOptions && destroyOptions.mode === \"split\") {\n            split(this.engine, this.container, particle);\n        }\n    }\n    update(particle) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        const position = particle.getPosition(), bounds = particle.destroyBounds;\n        if (!bounds) {\n            return;\n        }\n        if ((bounds.bottom !== undefined && position.y >= bounds.bottom) ||\n            (bounds.left !== undefined && position.x <= bounds.left) ||\n            (bounds.right !== undefined && position.x >= bounds.right) ||\n            (bounds.top !== undefined && position.y <= bounds.top)) {\n            particle.destroy();\n        }\n    }\n}\n","import { DestroyUpdater } from \"./DestroyUpdater\";\nexport async function loadDestroyUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"destroy\", (container) => new DestroyUpdater(engine, container), refresh);\n}\n","import { getRandom } from \"tsparticles-engine\";\nexport class CircleShape {\n    randomPosition(position, size, fill) {\n        const generateTheta = (x, y) => {\n            const u = getRandom() / 4.0, theta = Math.atan((y / x) * Math.tan(2 * Math.PI * u)), v = getRandom();\n            if (v < 0.25) {\n                return theta;\n            }\n            else if (v < 0.5) {\n                return Math.PI - theta;\n            }\n            else if (v < 0.75) {\n                return Math.PI + theta;\n            }\n            else {\n                return -theta;\n            }\n        }, radius = (x, y, theta) => (x * y) / Math.sqrt((y * Math.cos(theta)) ** 2 + (x * Math.sin(theta)) ** 2), [a, b] = [size.width / 2, size.height / 2], randomTheta = generateTheta(a, b), maxRadius = radius(a, b, randomTheta), randomRadius = fill ? maxRadius * Math.sqrt(getRandom()) : maxRadius;\n        return {\n            x: position.x + randomRadius * Math.cos(randomTheta),\n            y: position.y + randomRadius * Math.sin(randomTheta),\n        };\n    }\n}\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class EmitterLife {\n    constructor() {\n        this.wait = false;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.count !== undefined) {\n            this.count = data.count;\n        }\n        if (data.delay !== undefined) {\n            this.delay = setRangeValue(data.delay);\n        }\n        if (data.duration !== undefined) {\n            this.duration = setRangeValue(data.duration);\n        }\n        if (data.wait !== undefined) {\n            this.wait = data.wait;\n        }\n    }\n}\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class EmitterRate {\n    constructor() {\n        this.quantity = 1;\n        this.delay = 0.1;\n    }\n    load(data) {\n        if (data === undefined) {\n            return;\n        }\n        if (data.quantity !== undefined) {\n            this.quantity = setRangeValue(data.quantity);\n        }\n        if (data.delay !== undefined) {\n            this.delay = setRangeValue(data.delay);\n        }\n    }\n}\n","export class EmitterSize {\n    constructor() {\n        this.mode = \"percent\";\n        this.height = 0;\n        this.width = 0;\n    }\n    load(data) {\n        if (data === undefined) {\n            return;\n        }\n        if (data.mode !== undefined) {\n            this.mode = data.mode;\n        }\n        if (data.height !== undefined) {\n            this.height = data.height;\n        }\n        if (data.width !== undefined) {\n            this.width = data.width;\n        }\n    }\n}\n","import { AnimatableColor, deepExtend, executeOnSingleOrMultiple, setRangeValue, } from \"tsparticles-engine\";\nimport { EmitterLife } from \"./EmitterLife\";\nimport { EmitterRate } from \"./EmitterRate\";\nimport { EmitterSize } from \"./EmitterSize\";\nexport class Emitter {\n    constructor() {\n        this.autoPlay = true;\n        this.fill = true;\n        this.life = new EmitterLife();\n        this.rate = new EmitterRate();\n        this.shape = \"square\";\n        this.startCount = 0;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.autoPlay !== undefined) {\n            this.autoPlay = data.autoPlay;\n        }\n        if (data.size !== undefined) {\n            if (!this.size) {\n                this.size = new EmitterSize();\n            }\n            this.size.load(data.size);\n        }\n        if (data.direction !== undefined) {\n            this.direction = data.direction;\n        }\n        this.domId = data.domId;\n        if (data.fill !== undefined) {\n            this.fill = data.fill;\n        }\n        this.life.load(data.life);\n        this.name = data.name;\n        this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {\n            return deepExtend({}, particles);\n        });\n        this.rate.load(data.rate);\n        if (data.shape !== undefined) {\n            this.shape = data.shape;\n        }\n        if (data.position !== undefined) {\n            this.position = {};\n            if (data.position.x !== undefined) {\n                this.position.x = setRangeValue(data.position.x);\n            }\n            if (data.position.y !== undefined) {\n                this.position.y = setRangeValue(data.position.y);\n            }\n        }\n        if (data.spawnColor !== undefined) {\n            if (this.spawnColor === undefined) {\n                this.spawnColor = new AnimatableColor();\n            }\n            this.spawnColor.load(data.spawnColor);\n        }\n        if (data.startCount !== undefined) {\n            this.startCount = data.startCount;\n        }\n    }\n}\n","import { Vector, calcPositionOrRandomFromSizeRanged, deepExtend, getRangeValue, getSize, isPointInside, itemFromSingleOrMultiple, randomInRange, rangeColorToHsl, } from \"tsparticles-engine\";\nimport { Emitter } from \"./Options/Classes/Emitter\";\nimport { EmitterSize } from \"./Options/Classes/EmitterSize\";\nexport class EmitterInstance {\n    constructor(engine, emitters, container, options, position) {\n        this.emitters = emitters;\n        this.container = container;\n        this._calcPosition = () => {\n            return calcPositionOrRandomFromSizeRanged({\n                size: this.container.canvas.size,\n                position: this.options.position,\n            });\n        };\n        this._destroy = () => {\n            this.emitters.removeEmitter(this);\n            this._engine.dispatchEvent(\"emitterDestroyed\", {\n                container: this.container,\n                data: {\n                    emitter: this,\n                },\n            });\n        };\n        this._emit = () => {\n            if (this._paused) {\n                return;\n            }\n            const quantity = getRangeValue(this.options.rate.quantity);\n            this._emitParticles(quantity);\n        };\n        this._emitParticles = (quantity) => {\n            const position = this.getPosition(), size = this.getSize(), singleParticlesOptions = itemFromSingleOrMultiple(this._particlesOptions);\n            for (let i = 0; i < quantity; i++) {\n                const particlesOptions = deepExtend({}, singleParticlesOptions);\n                if (this.spawnColor) {\n                    const hslAnimation = this.options.spawnColor?.animation;\n                    if (hslAnimation) {\n                        this.spawnColor.h = this._setColorAnimation(hslAnimation.h, this.spawnColor.h, 360);\n                        this.spawnColor.s = this._setColorAnimation(hslAnimation.s, this.spawnColor.s, 100);\n                        this.spawnColor.l = this._setColorAnimation(hslAnimation.l, this.spawnColor.l, 100);\n                    }\n                    if (!particlesOptions.color) {\n                        particlesOptions.color = {\n                            value: this.spawnColor,\n                        };\n                    }\n                    else {\n                        particlesOptions.color.value = this.spawnColor;\n                    }\n                }\n                if (!position) {\n                    return;\n                }\n                const pPosition = this._shape?.randomPosition(position, size, this.fill) ?? position;\n                this.container.particles.addParticle(pPosition, particlesOptions);\n            }\n        };\n        this._prepareToDie = () => {\n            if (this._paused) {\n                return;\n            }\n            const duration = this.options.life?.duration !== undefined ? getRangeValue(this.options.life.duration) : undefined;\n            if (this.container.retina.reduceFactor &&\n                (this._lifeCount > 0 || this._immortal) &&\n                duration !== undefined &&\n                duration > 0) {\n                this._duration = duration * 1000;\n            }\n        };\n        this._setColorAnimation = (animation, initValue, maxValue) => {\n            const container = this.container;\n            if (!animation.enable) {\n                return initValue;\n            }\n            const colorOffset = randomInRange(animation.offset), delay = getRangeValue(this.options.rate.delay), emitFactor = (1000 * delay) / container.retina.reduceFactor, colorSpeed = getRangeValue(animation.speed ?? 0);\n            return (initValue + (colorSpeed * container.fpsLimit) / emitFactor + colorOffset * 3.6) % maxValue;\n        };\n        this._engine = engine;\n        this._currentDuration = 0;\n        this._currentEmitDelay = 0;\n        this._currentSpawnDelay = 0;\n        this._initialPosition = position;\n        if (options instanceof Emitter) {\n            this.options = options;\n        }\n        else {\n            this.options = new Emitter();\n            this.options.load(options);\n        }\n        this._spawnDelay = (getRangeValue(this.options.life.delay ?? 0) * 1000) / this.container.retina.reduceFactor;\n        this.position = this._initialPosition ?? this._calcPosition();\n        this.name = this.options.name;\n        this._shape = this._engine.emitterShapeManager?.getShape(this.options.shape);\n        this.fill = this.options.fill;\n        this._firstSpawn = !this.options.life.wait;\n        this._startParticlesAdded = false;\n        let particlesOptions = deepExtend({}, this.options.particles);\n        particlesOptions ??= {};\n        particlesOptions.move ??= {};\n        particlesOptions.move.direction ??= this.options.direction;\n        if (this.options.spawnColor) {\n            this.spawnColor = rangeColorToHsl(this.options.spawnColor);\n        }\n        this._paused = !this.options.autoPlay;\n        this._particlesOptions = particlesOptions;\n        this.size =\n            this.options.size ??\n                (() => {\n                    const size = new EmitterSize();\n                    size.load({\n                        height: 0,\n                        mode: \"percent\",\n                        width: 0,\n                    });\n                    return size;\n                })();\n        this._lifeCount = this.options.life.count ?? -1;\n        this._immortal = this._lifeCount <= 0;\n        this._engine.dispatchEvent(\"emitterCreated\", {\n            container,\n            data: {\n                emitter: this,\n            },\n        });\n        this.play();\n    }\n    externalPause() {\n        this._paused = true;\n        this.pause();\n    }\n    externalPlay() {\n        this._paused = false;\n        this.play();\n    }\n    getPosition() {\n        if (this.options.domId) {\n            const container = this.container, element = document.getElementById(this.options.domId);\n            if (element) {\n                const elRect = element.getBoundingClientRect();\n                return {\n                    x: (elRect.x + elRect.width / 2) * container.retina.pixelRatio,\n                    y: (elRect.y + elRect.height / 2) * container.retina.pixelRatio,\n                };\n            }\n        }\n        return this.position;\n    }\n    getSize() {\n        const container = this.container;\n        if (this.options.domId) {\n            const element = document.getElementById(this.options.domId);\n            if (element) {\n                const elRect = element.getBoundingClientRect();\n                return {\n                    width: elRect.width * container.retina.pixelRatio,\n                    height: elRect.height * container.retina.pixelRatio,\n                };\n            }\n        }\n        return getSize(this.size, container.canvas.size);\n    }\n    pause() {\n        if (this._paused) {\n            return;\n        }\n        delete this._emitDelay;\n    }\n    play() {\n        if (this._paused) {\n            return;\n        }\n        if (!(this.container.retina.reduceFactor &&\n            (this._lifeCount > 0 || this._immortal || !this.options.life.count) &&\n            (this._firstSpawn || this._currentSpawnDelay >= (this._spawnDelay ?? 0)))) {\n            return;\n        }\n        if (this._emitDelay === undefined) {\n            const delay = getRangeValue(this.options.rate.delay);\n            this._emitDelay = (1000 * delay) / this.container.retina.reduceFactor;\n        }\n        if (this._lifeCount > 0 || this._immortal) {\n            this._prepareToDie();\n        }\n    }\n    resize() {\n        const initialPosition = this._initialPosition;\n        this.position =\n            initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin)\n                ? initialPosition\n                : this._calcPosition();\n    }\n    update(delta) {\n        if (this._paused) {\n            return;\n        }\n        if (this._firstSpawn) {\n            this._firstSpawn = false;\n            this._currentSpawnDelay = this._spawnDelay ?? 0;\n            this._currentEmitDelay = this._emitDelay ?? 0;\n        }\n        if (!this._startParticlesAdded) {\n            this._startParticlesAdded = true;\n            this._emitParticles(this.options.startCount);\n        }\n        if (this._duration !== undefined) {\n            this._currentDuration += delta.value;\n            if (this._currentDuration >= this._duration) {\n                this.pause();\n                if (this._spawnDelay !== undefined) {\n                    delete this._spawnDelay;\n                }\n                if (!this._immortal) {\n                    this._lifeCount--;\n                }\n                if (this._lifeCount > 0 || this._immortal) {\n                    this.position = this._calcPosition();\n                    this._spawnDelay =\n                        (getRangeValue(this.options.life.delay ?? 0) * 1000) / this.container.retina.reduceFactor;\n                }\n                else {\n                    this._destroy();\n                }\n                this._currentDuration -= this._duration;\n                delete this._duration;\n            }\n        }\n        if (this._spawnDelay !== undefined) {\n            this._currentSpawnDelay += delta.value;\n            if (this._currentSpawnDelay >= this._spawnDelay) {\n                this._engine.dispatchEvent(\"emitterPlay\", {\n                    container: this.container,\n                });\n                this.play();\n                this._currentSpawnDelay -= this._currentSpawnDelay;\n                delete this._spawnDelay;\n            }\n        }\n        if (this._emitDelay !== undefined) {\n            this._currentEmitDelay += delta.value;\n            if (this._currentEmitDelay >= this._emitDelay) {\n                this._emit();\n                this._currentEmitDelay -= this._emitDelay;\n            }\n        }\n    }\n}\n","import { arrayRandomIndex, executeOnSingleOrMultiple, isArray, isNumber, itemFromArray, } from \"tsparticles-engine\";\nimport { Emitter } from \"./Options/Classes/Emitter\";\nimport { EmitterInstance } from \"./EmitterInstance\";\nexport class Emitters {\n    constructor(engine, container) {\n        this.container = container;\n        this._engine = engine;\n        this.array = [];\n        this.emitters = [];\n        this.interactivityEmitters = {\n            random: {\n                count: 1,\n                enable: false,\n            },\n            value: [],\n        };\n        container.getEmitter = (idxOrName) => idxOrName === undefined || isNumber(idxOrName)\n            ? this.array[idxOrName || 0]\n            : this.array.find((t) => t.name === idxOrName);\n        container.addEmitter = (options, position) => this.addEmitter(options, position);\n        container.removeEmitter = (idxOrName) => {\n            const emitter = container.getEmitter(idxOrName);\n            if (emitter) {\n                this.removeEmitter(emitter);\n            }\n        };\n        container.playEmitter = (idxOrName) => {\n            const emitter = container.getEmitter(idxOrName);\n            if (emitter) {\n                emitter.externalPlay();\n            }\n        };\n        container.pauseEmitter = (idxOrName) => {\n            const emitter = container.getEmitter(idxOrName);\n            if (emitter) {\n                emitter.externalPause();\n            }\n        };\n    }\n    addEmitter(options, position) {\n        const emitterOptions = new Emitter();\n        emitterOptions.load(options);\n        const emitter = new EmitterInstance(this._engine, this, this.container, emitterOptions, position);\n        this.array.push(emitter);\n        return emitter;\n    }\n    handleClickMode(mode) {\n        const emitterOptions = this.emitters, modeEmitters = this.interactivityEmitters;\n        if (mode !== \"emitter\") {\n            return;\n        }\n        let emittersModeOptions;\n        if (modeEmitters && isArray(modeEmitters.value)) {\n            if (modeEmitters.value.length > 0 && modeEmitters.random.enable) {\n                emittersModeOptions = [];\n                const usedIndexes = [];\n                for (let i = 0; i < modeEmitters.random.count; i++) {\n                    const idx = arrayRandomIndex(modeEmitters.value);\n                    if (usedIndexes.includes(idx) && usedIndexes.length < modeEmitters.value.length) {\n                        i--;\n                        continue;\n                    }\n                    usedIndexes.push(idx);\n                    emittersModeOptions.push(itemFromArray(modeEmitters.value, idx));\n                }\n            }\n            else {\n                emittersModeOptions = modeEmitters.value;\n            }\n        }\n        else {\n            emittersModeOptions = modeEmitters?.value;\n        }\n        const emittersOptions = emittersModeOptions ?? emitterOptions, ePosition = this.container.interactivity.mouse.clickPosition;\n        executeOnSingleOrMultiple(emittersOptions, (emitter) => {\n            this.addEmitter(emitter, ePosition);\n        });\n    }\n    async init() {\n        this.emitters = this.container.actualOptions.emitters;\n        this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters;\n        if (!this.emitters) {\n            return;\n        }\n        if (isArray(this.emitters)) {\n            for (const emitterOptions of this.emitters) {\n                this.addEmitter(emitterOptions);\n            }\n        }\n        else {\n            this.addEmitter(this.emitters);\n        }\n    }\n    pause() {\n        for (const emitter of this.array) {\n            emitter.pause();\n        }\n    }\n    play() {\n        for (const emitter of this.array) {\n            emitter.play();\n        }\n    }\n    removeEmitter(emitter) {\n        const index = this.array.indexOf(emitter);\n        if (index >= 0) {\n            this.array.splice(index, 1);\n        }\n    }\n    resize() {\n        for (const emitter of this.array) {\n            emitter.resize();\n        }\n    }\n    stop() {\n        this.array = [];\n    }\n    update(delta) {\n        for (const emitter of this.array) {\n            emitter.update(delta);\n        }\n    }\n}\n","const shapes = new Map();\nexport class ShapeManager {\n    constructor(engine) {\n        this._engine = engine;\n    }\n    addShape(name, drawer) {\n        if (!this.getShape(name)) {\n            shapes.set(name, drawer);\n        }\n    }\n    getShape(name) {\n        return shapes.get(name);\n    }\n    getSupportedShapes() {\n        return shapes.keys();\n    }\n}\n","import { getRandom } from \"tsparticles-engine\";\nfunction randomSquareCoordinate(position, offset) {\n    return position + offset * (getRandom() - 0.5);\n}\nexport class SquareShape {\n    randomPosition(position, size, fill) {\n        if (fill) {\n            return {\n                x: randomSquareCoordinate(position.x, size.width),\n                y: randomSquareCoordinate(position.y, size.height),\n            };\n        }\n        else {\n            const halfW = size.width / 2, halfH = size.height / 2, side = Math.floor(getRandom() * 4), v = (getRandom() - 0.5) * 2;\n            switch (side) {\n                case 0:\n                    return {\n                        x: position.x + v * halfW,\n                        y: position.y - halfH,\n                    };\n                case 1:\n                    return {\n                        x: position.x - halfW,\n                        y: position.y + v * halfH,\n                    };\n                case 2:\n                    return {\n                        x: position.x + v * halfW,\n                        y: position.y + halfH,\n                    };\n                case 3:\n                default:\n                    return {\n                        x: position.x + halfW,\n                        y: position.y + v * halfH,\n                    };\n            }\n        }\n    }\n}\n","import { executeOnSingleOrMultiple, isArray, isInArray, } from \"tsparticles-engine\";\nimport { CircleShape } from \"./Shapes/Circle/CircleShape\";\nimport { Emitter } from \"./Options/Classes/Emitter\";\nimport { Emitters } from \"./Emitters\";\nimport { ShapeManager } from \"./ShapeManager\";\nimport { SquareShape } from \"./Shapes/Square/SquareShape\";\nclass EmittersPlugin {\n    constructor(engine) {\n        this._engine = engine;\n        this.id = \"emitters\";\n    }\n    getPlugin(container) {\n        return new Emitters(this._engine, container);\n    }\n    loadOptions(options, source) {\n        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {\n            return;\n        }\n        if (source?.emitters) {\n            options.emitters = executeOnSingleOrMultiple(source.emitters, (emitter) => {\n                const tmp = new Emitter();\n                tmp.load(emitter);\n                return tmp;\n            });\n        }\n        const interactivityEmitters = source?.interactivity?.modes?.emitters;\n        if (interactivityEmitters) {\n            if (isArray(interactivityEmitters)) {\n                options.interactivity.modes.emitters = {\n                    random: {\n                        count: 1,\n                        enable: true,\n                    },\n                    value: interactivityEmitters.map((s) => {\n                        const tmp = new Emitter();\n                        tmp.load(s);\n                        return tmp;\n                    }),\n                };\n            }\n            else {\n                const emitterMode = interactivityEmitters;\n                if (emitterMode.value !== undefined) {\n                    if (isArray(emitterMode.value)) {\n                        options.interactivity.modes.emitters = {\n                            random: {\n                                count: emitterMode.random.count ?? 1,\n                                enable: emitterMode.random.enable ?? false,\n                            },\n                            value: emitterMode.value.map((s) => {\n                                const tmp = new Emitter();\n                                tmp.load(s);\n                                return tmp;\n                            }),\n                        };\n                    }\n                    else {\n                        const tmp = new Emitter();\n                        tmp.load(emitterMode.value);\n                        options.interactivity.modes.emitters = {\n                            random: {\n                                count: emitterMode.random.count ?? 1,\n                                enable: emitterMode.random.enable ?? false,\n                            },\n                            value: tmp,\n                        };\n                    }\n                }\n                else {\n                    const emitterOptions = (options.interactivity.modes.emitters = {\n                        random: {\n                            count: 1,\n                            enable: false,\n                        },\n                        value: new Emitter(),\n                    });\n                    emitterOptions.value.load(interactivityEmitters);\n                }\n            }\n        }\n    }\n    needsPlugin(options) {\n        if (!options) {\n            return false;\n        }\n        const emitters = options.emitters;\n        return ((isArray(emitters) && !!emitters.length) ||\n            emitters !== undefined ||\n            (!!options.interactivity?.events?.onClick?.mode &&\n                isInArray(\"emitter\", options.interactivity.events.onClick.mode)));\n    }\n}\nexport async function loadEmittersPlugin(engine, refresh = true) {\n    if (!engine.emitterShapeManager) {\n        engine.emitterShapeManager = new ShapeManager(engine);\n    }\n    if (!engine.addEmitterShape) {\n        engine.addEmitterShape = (name, shape) => {\n            engine.emitterShapeManager?.addShape(name, shape);\n        };\n    }\n    const plugin = new EmittersPlugin(engine);\n    await engine.addPlugin(plugin, refresh);\n    engine.addEmitterShape(\"circle\", new CircleShape());\n    engine.addEmitterShape(\"square\", new SquareShape());\n}\nexport * from \"./EmitterContainer\";\nexport * from \"./EmittersEngine\";\nexport * from \"./Enums/EmitterClickMode\";\nexport * from \"./Enums/EmitterShapeType\";\n","import { deepExtend } from \"tsparticles-engine\";\nexport class Trail {\n    constructor() {\n        this.delay = 1;\n        this.pauseOnStop = false;\n        this.quantity = 1;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.delay !== undefined) {\n            this.delay = data.delay;\n        }\n        if (data.quantity !== undefined) {\n            this.quantity = data.quantity;\n        }\n        if (data.particles !== undefined) {\n            this.particles = deepExtend({}, data.particles);\n        }\n        if (data.pauseOnStop !== undefined) {\n            this.pauseOnStop = data.pauseOnStop;\n        }\n    }\n}\n","import { ExternalInteractorBase, isInArray, } from \"tsparticles-engine\";\nimport { Trail } from \"./Options/Classes/Trail\";\nexport class TrailMaker extends ExternalInteractorBase {\n    constructor(container) {\n        super(container);\n        this._delay = 0;\n    }\n    clear() {\n    }\n    init() {\n    }\n    async interact(delta) {\n        const container = this.container, { interactivity } = container;\n        if (!container.retina.reduceFactor) {\n            return;\n        }\n        const options = container.actualOptions, trailOptions = options.interactivity.modes.trail;\n        if (!trailOptions) {\n            return;\n        }\n        const optDelay = (trailOptions.delay * 1000) / this.container.retina.reduceFactor;\n        if (this._delay < optDelay) {\n            this._delay += delta.value;\n        }\n        if (this._delay < optDelay) {\n            return;\n        }\n        const canEmit = !(trailOptions.pauseOnStop &&\n            (interactivity.mouse.position === this._lastPosition ||\n                (interactivity.mouse.position?.x === this._lastPosition?.x &&\n                    interactivity.mouse.position?.y === this._lastPosition?.y)));\n        const mousePos = container.interactivity.mouse.position;\n        if (mousePos) {\n            this._lastPosition = { ...mousePos };\n        }\n        else {\n            delete this._lastPosition;\n        }\n        if (canEmit) {\n            container.particles.push(trailOptions.quantity, container.interactivity.mouse, trailOptions.particles);\n        }\n        this._delay -= optDelay;\n    }\n    isEnabled(particle) {\n        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = (particle?.interactivity ?? options.interactivity).events;\n        return ((mouse.clicking && mouse.inside && !!mouse.position && isInArray(\"trail\", events.onClick.mode)) ||\n            (mouse.inside && !!mouse.position && isInArray(\"trail\", events.onHover.mode)));\n    }\n    loadModeOptions(options, ...sources) {\n        if (!options.trail) {\n            options.trail = new Trail();\n        }\n        for (const source of sources) {\n            options.trail.load(source?.trail);\n        }\n    }\n    reset() {\n    }\n}\n","import { TrailMaker } from \"./TrailMaker\";\nexport async function loadExternalTrailInteraction(engine, refresh = true) {\n    await engine.addInteractor(\"externalTrail\", (container) => new TrailMaker(container), refresh);\n}\nexport * from \"./Options/Classes/Trail\";\nexport * from \"./Options/Interfaces/ITrail\";\n","import { getRandom, getRangeValue, rangeColorToHsl } from \"tsparticles-engine\";\nexport function initParticle(particle) {\n    const rollOpt = particle.options.roll;\n    if (!rollOpt?.enable) {\n        particle.roll = {\n            enable: false,\n            horizontal: false,\n            vertical: false,\n            angle: 0,\n            speed: 0,\n        };\n        return;\n    }\n    particle.roll = {\n        enable: rollOpt.enable,\n        horizontal: rollOpt.mode === \"horizontal\" || rollOpt.mode === \"both\",\n        vertical: rollOpt.mode === \"vertical\" || rollOpt.mode === \"both\",\n        angle: getRandom() * Math.PI * 2,\n        speed: getRangeValue(rollOpt.speed) / 360,\n    };\n    if (rollOpt.backColor) {\n        particle.backColor = rangeColorToHsl(rollOpt.backColor);\n    }\n    else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {\n        const alterType = getRandom() >= 0.5 ? \"darken\" : \"enlighten\";\n        particle.roll.alter = {\n            type: alterType,\n            value: getRangeValue(alterType === \"darken\" ? rollOpt.darken.value : rollOpt.enlighten.value),\n        };\n    }\n    else if (rollOpt.darken.enable) {\n        particle.roll.alter = {\n            type: \"darken\",\n            value: getRangeValue(rollOpt.darken.value),\n        };\n    }\n    else if (rollOpt.enlighten.enable) {\n        particle.roll.alter = {\n            type: \"enlighten\",\n            value: getRangeValue(rollOpt.enlighten.value),\n        };\n    }\n}\nexport function updateRoll(particle, delta) {\n    const roll = particle.options.roll, data = particle.roll;\n    if (!data || !roll?.enable) {\n        return;\n    }\n    const speed = data.speed * delta.factor, max = 2 * Math.PI;\n    data.angle += speed;\n    if (data.angle > max) {\n        data.angle -= max;\n    }\n}\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class RollLight {\n    constructor() {\n        this.enable = false;\n        this.value = 0;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.value !== undefined) {\n            this.value = setRangeValue(data.value);\n        }\n    }\n}\n","import { OptionsColor, setRangeValue, } from \"tsparticles-engine\";\nimport { RollLight } from \"./RollLight\";\nexport class Roll {\n    constructor() {\n        this.darken = new RollLight();\n        this.enable = false;\n        this.enlighten = new RollLight();\n        this.mode = \"vertical\";\n        this.speed = 25;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.backColor !== undefined) {\n            this.backColor = OptionsColor.create(this.backColor, data.backColor);\n        }\n        this.darken.load(data.darken);\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        this.enlighten.load(data.enlighten);\n        if (data.mode !== undefined) {\n            this.mode = data.mode;\n        }\n        if (data.speed !== undefined) {\n            this.speed = setRangeValue(data.speed);\n        }\n    }\n}\n","import { initParticle, updateRoll } from \"./Utils\";\nimport { Roll } from \"./Options/Classes/Roll\";\nexport class RollUpdater {\n    getTransformValues(particle) {\n        const roll = particle.roll?.enable && particle.roll, rollHorizontal = roll && roll.horizontal, rollVertical = roll && roll.vertical;\n        return {\n            a: rollHorizontal ? Math.cos(roll.angle) : undefined,\n            d: rollVertical ? Math.sin(roll.angle) : undefined,\n        };\n    }\n    init(particle) {\n        initParticle(particle);\n    }\n    isEnabled(particle) {\n        const roll = particle.options.roll;\n        return !particle.destroyed && !particle.spawning && !!roll?.enable;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.roll) {\n            options.roll = new Roll();\n        }\n        for (const source of sources) {\n            options.roll.load(source?.roll);\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateRoll(particle, delta);\n    }\n}\n","import { RollUpdater } from \"./RollUpdater\";\nexport async function loadRollUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"roll\", () => new RollUpdater(), refresh);\n}\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class TiltAnimation {\n    constructor() {\n        this.enable = false;\n        this.speed = 0;\n        this.decay = 0;\n        this.sync = false;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.speed !== undefined) {\n            this.speed = setRangeValue(data.speed);\n        }\n        if (data.decay !== undefined) {\n            this.decay = setRangeValue(data.decay);\n        }\n        if (data.sync !== undefined) {\n            this.sync = data.sync;\n        }\n    }\n}\n","import { ValueWithRandom } from \"tsparticles-engine\";\nimport { TiltAnimation } from \"./TiltAnimation\";\nexport class Tilt extends ValueWithRandom {\n    constructor() {\n        super();\n        this.animation = new TiltAnimation();\n        this.direction = \"clockwise\";\n        this.enable = false;\n        this.value = 0;\n    }\n    load(data) {\n        super.load(data);\n        if (!data) {\n            return;\n        }\n        this.animation.load(data.animation);\n        if (data.direction !== undefined) {\n            this.direction = data.direction;\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n    }\n}\n","export function updateTilt(particle, delta) {\n    if (!particle.tilt || !particle.options.tilt) {\n        return;\n    }\n    const tilt = particle.options.tilt, tiltAnimation = tilt.animation, speed = (particle.tilt.velocity ?? 0) * delta.factor, max = 2 * Math.PI, decay = particle.tilt.decay ?? 1;\n    if (!tiltAnimation.enable) {\n        return;\n    }\n    switch (particle.tilt.status) {\n        case \"increasing\":\n            particle.tilt.value += speed;\n            if (particle.tilt.value > max) {\n                particle.tilt.value -= max;\n            }\n            break;\n        case \"decreasing\":\n        default:\n            particle.tilt.value -= speed;\n            if (particle.tilt.value < 0) {\n                particle.tilt.value += max;\n            }\n            break;\n    }\n    if (particle.tilt.velocity && decay !== 1) {\n        particle.tilt.velocity *= decay;\n    }\n}\n","import { getRandom, getRangeValue, } from \"tsparticles-engine\";\nimport { Tilt } from \"./Options/Classes/Tilt\";\nimport { updateTilt } from \"./Utils\";\nexport class TiltUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    getTransformValues(particle) {\n        const tilt = particle.tilt?.enable && particle.tilt;\n        return {\n            b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : undefined,\n            c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : undefined,\n        };\n    }\n    init(particle) {\n        const tiltOptions = particle.options.tilt;\n        if (!tiltOptions) {\n            return;\n        }\n        particle.tilt = {\n            enable: tiltOptions.enable,\n            value: (getRangeValue(tiltOptions.value) * Math.PI) / 180,\n            sinDirection: getRandom() >= 0.5 ? 1 : -1,\n            cosDirection: getRandom() >= 0.5 ? 1 : -1,\n        };\n        let tiltDirection = tiltOptions.direction;\n        if (tiltDirection === \"random\") {\n            const index = Math.floor(getRandom() * 2);\n            tiltDirection = index > 0 ? \"counter-clockwise\" : \"clockwise\";\n        }\n        switch (tiltDirection) {\n            case \"counter-clockwise\":\n            case \"counterClockwise\":\n                particle.tilt.status = \"decreasing\";\n                break;\n            case \"clockwise\":\n                particle.tilt.status = \"increasing\";\n                break;\n        }\n        const tiltAnimation = particle.options.tilt?.animation;\n        if (tiltAnimation?.enable) {\n            particle.tilt.decay = 1 - getRangeValue(tiltAnimation.decay);\n            particle.tilt.velocity = (getRangeValue(tiltAnimation.speed) / 360) * this.container.retina.reduceFactor;\n            if (!tiltAnimation.sync) {\n                particle.tilt.velocity *= getRandom();\n            }\n        }\n    }\n    isEnabled(particle) {\n        const tiltAnimation = particle.options.tilt?.animation;\n        return !particle.destroyed && !particle.spawning && !!tiltAnimation?.enable;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.tilt) {\n            options.tilt = new Tilt();\n        }\n        for (const source of sources) {\n            options.tilt.load(source?.tilt);\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateTilt(particle, delta);\n    }\n}\n","import { TiltUpdater } from \"./TiltUpdater\";\nexport async function loadTiltUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"tilt\", (container) => new TiltUpdater(container), refresh);\n}\n","import { OptionsColor, setRangeValue, } from \"tsparticles-engine\";\nexport class TwinkleValues {\n    constructor() {\n        this.enable = false;\n        this.frequency = 0.05;\n        this.opacity = 1;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.color !== undefined) {\n            this.color = OptionsColor.create(this.color, data.color);\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.frequency !== undefined) {\n            this.frequency = data.frequency;\n        }\n        if (data.opacity !== undefined) {\n            this.opacity = setRangeValue(data.opacity);\n        }\n    }\n}\n","import { TwinkleValues } from \"./TwinkleValues\";\nexport class Twinkle {\n    constructor() {\n        this.lines = new TwinkleValues();\n        this.particles = new TwinkleValues();\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        this.lines.load(data.lines);\n        this.particles.load(data.particles);\n    }\n}\n","import { getRandom, getRangeValue, getStyleFromHsl, rangeColorToHsl, } from \"tsparticles-engine\";\nimport { Twinkle } from \"./Options/Classes/Twinkle\";\nexport class TwinkleUpdater {\n    getColorStyles(particle, context, radius, opacity) {\n        const pOptions = particle.options, twinkleOptions = pOptions.twinkle;\n        if (!twinkleOptions) {\n            return {};\n        }\n        const twinkle = twinkleOptions.particles, twinkling = twinkle.enable && getRandom() < twinkle.frequency, zIndexOptions = particle.options.zIndex, zOpacityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.opacityRate, twinklingOpacity = twinkling ? getRangeValue(twinkle.opacity) * zOpacityFactor : opacity, twinkleRgb = rangeColorToHsl(twinkle.color), twinkleStyle = twinkleRgb ? getStyleFromHsl(twinkleRgb, twinklingOpacity) : undefined, res = {}, needsTwinkle = twinkling && twinkleStyle;\n        res.fill = needsTwinkle ? twinkleStyle : undefined;\n        res.stroke = needsTwinkle ? twinkleStyle : undefined;\n        return res;\n    }\n    init() {\n    }\n    isEnabled(particle) {\n        const pOptions = particle.options, twinkleOptions = pOptions.twinkle;\n        if (!twinkleOptions) {\n            return false;\n        }\n        return twinkleOptions.particles.enable;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.twinkle) {\n            options.twinkle = new Twinkle();\n        }\n        for (const source of sources) {\n            options.twinkle.load(source?.twinkle);\n        }\n    }\n    update() {\n    }\n}\n","import { TwinkleUpdater } from \"./TwinkleUpdater\";\nexport async function loadTwinkleUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"twinkle\", () => new TwinkleUpdater(), refresh);\n}\n","import { setRangeValue } from \"tsparticles-engine\";\nexport class WobbleSpeed {\n    constructor() {\n        this.angle = 50;\n        this.move = 10;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.angle !== undefined) {\n            this.angle = setRangeValue(data.angle);\n        }\n        if (data.move !== undefined) {\n            this.move = setRangeValue(data.move);\n        }\n    }\n}\n","import { isNumber, setRangeValue, } from \"tsparticles-engine\";\nimport { WobbleSpeed } from \"./WobbleSpeed\";\nexport class Wobble {\n    constructor() {\n        this.distance = 5;\n        this.enable = false;\n        this.speed = new WobbleSpeed();\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.distance !== undefined) {\n            this.distance = setRangeValue(data.distance);\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.speed !== undefined) {\n            if (isNumber(data.speed)) {\n                this.speed.load({ angle: data.speed });\n            }\n            else {\n                const rangeSpeed = data.speed;\n                if (rangeSpeed.min !== undefined) {\n                    this.speed.load({ angle: rangeSpeed });\n                }\n                else {\n                    this.speed.load(data.speed);\n                }\n            }\n        }\n    }\n}\n","export function updateWobble(particle, delta) {\n    const { wobble: wobbleOptions } = particle.options, { wobble } = particle;\n    if (!wobbleOptions?.enable || !wobble) {\n        return;\n    }\n    const angleSpeed = wobble.angleSpeed * delta.factor, moveSpeed = wobble.moveSpeed * delta.factor, distance = (moveSpeed * ((particle.retina.wobbleDistance ?? 0) * delta.factor)) / (1000 / 60), max = 2 * Math.PI, { position } = particle;\n    wobble.angle += angleSpeed;\n    if (wobble.angle > max) {\n        wobble.angle -= max;\n    }\n    position.x += distance * Math.cos(wobble.angle);\n    position.y += distance * Math.abs(Math.sin(wobble.angle));\n}\n","import { getRandom, getRangeValue, } from \"tsparticles-engine\";\nimport { Wobble } from \"./Options/Classes/Wobble\";\nimport { updateWobble } from \"./Utils\";\nexport class WobbleUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    init(particle) {\n        const wobbleOpt = particle.options.wobble;\n        if (wobbleOpt?.enable) {\n            particle.wobble = {\n                angle: getRandom() * Math.PI * 2,\n                angleSpeed: getRangeValue(wobbleOpt.speed.angle) / 360,\n                moveSpeed: getRangeValue(wobbleOpt.speed.move) / 10,\n            };\n        }\n        else {\n            particle.wobble = {\n                angle: 0,\n                angleSpeed: 0,\n                moveSpeed: 0,\n            };\n        }\n        particle.retina.wobbleDistance = getRangeValue(wobbleOpt?.distance ?? 0) * this.container.retina.pixelRatio;\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning && !!particle.options.wobble?.enable;\n    }\n    loadOptions(options, ...sources) {\n        if (!options.wobble) {\n            options.wobble = new Wobble();\n        }\n        for (const source of sources) {\n            options.wobble.load(source?.wobble);\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateWobble(particle, delta);\n    }\n}\n","import { WobbleUpdater } from \"./WobbleUpdater\";\nexport async function loadWobbleUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"wobble\", (container) => new WobbleUpdater(container), refresh);\n}\n","import { loadAbsorbersPlugin } from \"tsparticles-plugin-absorbers\";\nimport { loadDestroyUpdater } from \"tsparticles-updater-destroy\";\nimport { loadEmittersPlugin } from \"tsparticles-plugin-emitters\";\nimport { loadExternalTrailInteraction } from \"tsparticles-interaction-external-trail\";\nimport { loadRollUpdater } from \"tsparticles-updater-roll\";\nimport { loadSlim } from \"tsparticles-slim\";\nimport { loadTiltUpdater } from \"tsparticles-updater-tilt\";\nimport { loadTwinkleUpdater } from \"tsparticles-updater-twinkle\";\nimport { loadWobbleUpdater } from \"tsparticles-updater-wobble\";\nexport async function loadFull(engine, refresh = true) {\n    await loadDestroyUpdater(engine, false);\n    await loadRollUpdater(engine, false);\n    await loadTiltUpdater(engine, false);\n    await loadTwinkleUpdater(engine, false);\n    await loadWobbleUpdater(engine, false);\n    await loadExternalTrailInteraction(engine, false);\n    await loadAbsorbersPlugin(engine, false);\n    await loadEmittersPlugin(engine, false);\n    await loadSlim(engine, refresh);\n}\n"],"mappings":"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"}